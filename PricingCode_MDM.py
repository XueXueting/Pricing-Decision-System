#!/usr/bin/env python
# coding: utf-8

# # Pricing Experiments Using MDM
# 
# 

# 
# 

# ## Work enviroment
# 
# #### Please ensure that you have the following packages installed
# pulp; math; pandas; numpy; matplotlib; xlrd; random; time; pickle; os; cvxpy; cvxopt

# In[1]:


# get_ipython().system('python --version')


# In[ ]:





# In[ ]:





# In[2]:


import pulp
import sys
from MDM_lib import *
# pulp.pulpTestAll()


# In[3]:


# conda install -c conda-forge lapack


# In[4]:


#pip install cvxpy


# # Solver Set-up
# 
# #### We use CBC solver (open source) as our default solver for most optimization problems below. 
#  CBC comes along with the pulp python package, so there is no need to install another copy
# 

# ### If you wish to change the default solver, 
#  please visit the MDM_lib.py file, 
# and search for the $\textbf{Solver_setup}$ variable and change it's value
# 
# Examples are presented below

# In[5]:


Solver_setup = PULP_CBC_CMD()
# Solver_setup =CPLEX_CMD()   Set CPLEX as solver, requires Liscence 
# Solver_setup = GUROBI_CMD() Set Gurobi as solver, requires Liscence
# Solver_setup = MOSEK()      Set Mosek as solver, requires Lisence 


# # Experiment 1: Pricing on Surplus-Maximization choice model

# ## Synthetic Data Generating Set-up

# In[6]:


MaxSimIter=1
maxn=10 
VMaxIter=1000 
vsampleN=100
MaxIterM=100

# x = [([9,1,0.3,1,5,0.1,0.3,1,0.9,0.1,0.3,1,0.9,0.1,0.3,1,0.9,0.1,0.3,1],100)]
# print(type(x))
# cons = '9,1,0.3,1,5,0.1,0.3,1,0.9,0.1,0.3,1,0.9,0.1,0.3,1,0.9,0.1,0.3,1,100'
cons = sys.argv[3]
# sys.argv[3] = '100'
if(len(cons) > 2):
    arr = cons.split(',')
b = float(arr[len(arr)-1])
c = arr.pop(len(arr)-1)
arr = [float(i) for i in arr]
UserConstraints = [(arr,b)]
# print(type(b))
# print(b)
# print(arr)
# print(type(arr))
# print(type(UserConstraints))
# getUserConstraints(UserConstraints)
# getUserConstraints(sys.argv[2])


# ## Notation of the Parameters

# $$
# \textbf{MaxSimIter} \textit{ :  The number of repeated experiment we are doing.                  Default:} \ \mathbf{1} \\
# \textbf{maxn} \textit{ : Maximal number of products to the valuationation pool.  Default:}  \ \mathbf{10} \\
# \textbf{VMaxIter} \textit{ : Size of the valuation pool (interpreted as number of customers' valuation on different product).                      Default:} \ \mathbf{1000} \\
# \textbf{VSampleN} \textit{ : The number of valuations sampled from the valuation pool to be used in the MIP model. Default:} \ \mathbf{100} \\
# \textbf{MaxIterM} \textit{ : Maximal number of pricing experiments tested. Default:} \ \mathbf{100} \\
# $$
# 
# 

# ## Part 1a: Synthetic Data Generation
# ### We demonstrate the use of each function 

# In[7]:


V_full, vc_full = fun_valuation_pool_generation_mixed_lognormalUniform(VMaxIter, maxn, MaxSimIter)


# We consider the Surplus-maximation model, which is defined as follows: 
# 
# $\textit{The population consists of several segment of equal proportion. People in each segment have their own valuation on all  products.}$ \
# $\textit{Each customer will purchase the item with maximum surplus, the value of his valuation - market price}$
# 
# This function severs to generate the valuation value for the Surplus maximization model, which proceeds in the following steps: 
# 
# $\textbf{Step 1.}$ We generate the value of $\mathbf{V}$ by 
# $$
# V_{j} = j + u_{1j}
# $$   $\qquad \ \ \   $Here $u_{1j} \sim \mathcal{U}[0,1]$. Hence $V_j$ is between $(j,j+1)$.
# 
# $\textbf{Step 2.}$ Given this vector $\mathbf{V}$, we generate the valuation $vc$ of all selected products. The first half 5 items' valuation are generated by 
# $$
# vc_{j}= (1 + u_{2j})V_j, j = 1,...,5 
# $$ $\qquad \ \ \   $Here $u_{2j} \sim \mathcal{U} [-\frac{1}{2}, \frac{1}{2}]$, the mean of the uniform variable is $V_j$ and variance is $\frac{1}{12}V_j^2$ . \
# $\qquad \ \ \   $The other half 5 items' valuation are generated by 
# $$
# %vc_{j} \sim LogNormal(\log V_{j} - 0.04,0.283)
# vc_{j} \sim LogNormal(\mu_j,\sigma_j^2)
# $$
# with 
# $$
#  \mu_j =2log(V_{j})-0.5*log(V_j^2+\frac{1}{12}V_j^2)
#  $$
#  and $$
#  \sigma_j^2=log(V_j^2+\frac{1}{12}V_j^2) - log(V_{j}^2)
#  $$
#  Hence the mean of the log-normal variable is $V_j$ and variance is $\frac{1}{12}V_j^2$

# In[8]:


p_full,x_full=fun_PricePoolGeneration(MaxIterM,vc_full)


# In this step, we first we set 
# $$
# VG_{j} = \frac{1}{VMaxIter}  \sum_{i=1}^{VMaxIter}vc_{i,j} 
# $$
# as the mean of $vc$ across all pools for the same product $j$ 
# 
# Uniformly sample prices around 20% of $VG_{j}$, i.e. initiate the price pool by 
# $$
# p_{j,i} =  (1 + 0.4 u_{j,i})\cdot  VG_i  
# $$where $u_{j,i} \sim \mathcal{U}[-\frac{1}{2}, \frac{1}{2}]$ is i.i.d uniform random variable.
# 
# Since we are assume the consumer choice model to be surplus maximization choice model,
# 
# provided with the price $\mathbf{p}$, the choice probabilities (market share) are given as:
# $$
# x_j(\mathbf{p}) = \frac{ \sum_{i=1}^{\textit{VMaxIter}} \mathbb{1}\big\{ \ j = \textit{argmax}_{l= 0,1,...,\textit{maxn}} \{vc_{i,l} - p_l\} \ \big\}   }{ VMaxIter }
# $$

# # Part 1b: Pricing Optimization with Benchmarks

# ## Part 1b.1 MIP Pricing Model with Sampled Valuation

# In[9]:


ind = list(range(VMaxIter))
sample_ind100=np.array(random.sample(ind,vsampleN))


# Among all 1000 different valuation pools (cusomters), we randomly choose $\textit{vsampleN} = 100$ number of them, which will be used in the MIP model. The sample valuation index is in $\textit{sample_ind100}$

# In[10]:


list_Prod_index = list();
list_Prod_index.append([2,3,4,5])
#list_Prod_index.append([0,1,2,3,4,9])


# This command set up the indexs of products that will be used to test our experiment
# 
# The default set of index is {2, 6, 10}, i.e. The 2nd, 6th and 10th product will be used for testing.
# 
# More product index combinations can be added in the list.

# In[11]:


lt = 0
Prod_index = list_Prod_index[lt]
vc = vc_full[:,Prod_index,:]


# lt denotes the index of the list $\textit{list_Prod_index}$, each element in the $\textit{Prod_index}$ records the products to be tested in the following.

# In[12]:


VMaxIter, n, MaxSimIter = vc.shape


# ##### Generated Valuation Data

# In[13]:


from IPython.display import display, HTML
for t in range(MaxSimIter):
    print(str(VMaxIter)+" valuations for each product in " + str(t) +"'s experiment are:")
    df=pd.DataFrame(vc[:,:,0])
    df.columns = np.array(["Product "+str(i) for i in range(n)])
    display(df)


# ##### Input of MIP model

# In[14]:


for t in range(MaxSimIter):
    print(str(vsampleN)+" sampled valuations for each product for MIP model in " + str(t) +"'s experiment are:")
    df_s=pd.DataFrame(vc[sample_ind100,:,0])
    df_s.columns = np.array(["Product "+str(i) for i in range(n)])
    display(df_s)


# In[15]:


Cost = np.zeros(n)


# Here we set the cost of all test items as 0

# In[16]:


pOpt, profit_true, duration_true = fun_true_pricing_MIP(vc,sample_ind100,Cost)


# $\textbf{Input:}$
# $$
# \mathbf{vc} \textit{ : The valuations for the tested products in the valuation pool } \\
# \mathbf{sample\_ind100} \textit{ : The set of indics for the valuations in the valuation pool, which is used in MIP } \\
# $$
# $\textbf{Output:}$
# $$
# \mathbf{pOpt} \textit{ : The optimal market share of products given the valuation of all customers} \\
# \mathbf{profit\_true} \textit{ : The optimal profit}\\
# \mathbf{duration\_true} \textit{ : The time spent on solving this Mixed-Integer optmization problem}\\
# $$
# 
# A detailed documentation of this funtion can be found below. 

# ### Function 1ï¼š fun_true_pricing_MIP(vc, sample_ind100, cost)
# 

# #### Here is an detailed description of the function $\textit{fun_true_pricing_MIP}$

# The function is to  execute $\textit{Pricing_Valuation_SAA_ms_Gurobi(vc,:)}$ $\textit{MaxSimIter}$ times \
# With the optimized $p^*$, we calculate the true optimal gross profit $\sum_{j=1}^N (p_j - \omega_j) x_j(\mathbf{p}) $, where $x_j(\mathbf{p})$ is evaluated under the surplus maximization model from all the valuations of the tested products in the valuation pool.

# #### Subfunction 1.1: Pricing_Valuation_SAA_ms_pulp(vc)

# ##### Here is an detailed description of the function $\textit{Pricing_Valuation_SAA_ms_pulp}$

# This is the MIP formulation of optimal product(bundle) pricing under the Surplus-Maximization Choice model. For the convenience in notation, we set $M = \textit{MaxIterM}$. \
# This MIP solves the following optimization problem
# 
# $$ \begin{align}
# \max \  & \frac{1}{M} \sum_{k=1}^{M} \sum_{i=1}^{n} z_{ki} \hfill \\
# \textit{s.t.}\quad &\hfill \textbf{Single Price Schedule} \\
# & z_{ki} \leq p_i, \quad \forall k=1,...,M; \quad i = 1,...,n   \\
# & z_{ki} \geq p_i - \big(\max_{k,i}\{v_{ki}\}\big)  (1 - y_{ki}), \quad \forall k = 1,...,M; \quad i = 1,...,n\\
# &\textbf{Consumer Surplus} \\
# & s_{ki} = v_{ki} y_{ki} - z_{ki} , \quad \forall k = 1,...,M; \quad i = 1,...,n\\
# & \textbf{Single Purchase} \\
# & \sum_{i=1}^n  y_{ki} \leq 1, \quad \forall k = 1,...,M\\
# &\sum_{j=1}^n s_{kj} \geq v_{ki} - p_i \quad \forall k = 1,...,M; \quad i = 1,...,n\\
# & \textbf{Tightening Constraints} \\
# &\sum_{j=1}^n s_{kj} \geq \sum_{j=1}^n (v_{kj} y_{lj} - z_{lj}), \quad \forall l=1,...,M; \quad l=1,...,M \\
# &  p_i,z_{ki}, s_{ki} \geq 0 \quad y_{ki} \in \{0,1\} , \quad \forall k = 1,...,M; \quad i = 1,...,n \\
# \end{align}
# $$
# 
# Here,\
# $$
# v_{ki}:\ \textit{customer k's valuation on product i }\textbf{(constant) } \\
# p_i:\ \textit{price of product i } \textbf{(decision variable)} \\
# z_{ki}:\ \textit{the marginal revenue generated from customer k if he select product i  }  \textbf{(auxiliary variable)}\\
# s_{ki}:\ \textit{the consumer surplus if customer k select product i  }  \textbf{(auxiliary variable)}\\
# $$

# ## Part 1b.2 Pricing with MDM model

# In[17]:


psample_ind=fun_incre_price_experiment_index(MaxIterM)


# We subcategory the price pool sequencially into sub-bundles of size 90, 80, 70, 60, 50, 40, 30, 20, 10, 5. The sampled price index is in $\textit{psample_ind}$,
# 
# Note that each bundle sepcified by $\textit{psample_ind[i]}$  is the sub-bundle of the bundle specified by $\textit{psample_ind[i+1]}$ for all $\textit{i}$

# In[18]:


k = 9
MaxIter = len(psample_ind[k])


# * get the price sample for MDM, whose index is sepcided by $\textit{psample_ind[k]}$
# * $\textit{MaxIter}$ specifies the number of price experiments used in the MDM model
# * When $k$ varies from $0$ to $9$, $\textit{MaxIter}$ varies from $5$ to $90$

# In[19]:


p_subsets_aggr, x_subsets_aggr= fun_shareGeneration(p_full, psample_ind[k], list_Prod_index[lt],vc)


# * $\textit{fun_shareGeneration}$ generates the experiment data (including prices and shares) for MDM model from the previsou step
# * $\textit{p_subsets_aggr}$ indicates the price data from the previous price sample index
# * $\textit{x_subsets_aggr}$ indicates the share data for $\textit{p_subsets_aggr}$ calculated from the surplus maximization model using all the valuations of the tested products in the valuation pool.

# ##### Input for MDM Model

# In[20]:


for t in range(MaxSimIter):
    print("Prices and shares for "+str(n)+" product at "+str(MaxIter)+" time periods in " + str(t) +"'s experiment are:")
    data_v=np.c_[p_subsets_aggr[:,:,0],x_subsets_aggr[:,:,0]]
    cn_v=np.r_[np.array(["Price "+str(i) for i in range(n)]),np.array(["Share "+str(i) for i in range(n+1)])]
    #np.c_[np.array(["Price "+str(i) for i in range(n)]),np.array(["Share "+str(i) for i in range(n)])]
    df_input_MDM=pd.DataFrame(data_v)
    df_input_MDM.columns = cn_v
    display(df_input_MDM)


# In[21]:


P,sharematrix,indexoforder =data_preprocess(p_subsets_aggr[:,:,0],x_subsets_aggr[:,:,0])


# * This command modifies the data into the form that the MDM method can process
# * The last parameter in $\textit{p_subsets_aggr[:,:,0],x_subsets_aggr[:,:,0]}$ indicates the index of the independent simulation experiment, which varies from 0 to $\textit{MaxSimIter-1}$. The default value for $\textit{MaxSimIter}$ is 1 hence the default value for the last parameter is 0.

# In[22]:


print(p_subsets_aggr)


# In[23]:


print(x_subsets_aggr)


# In[24]:


print(vc)


# In[25]:


print(Cost)


# In[26]:


# Pptimalprice_MDMprice, Profit_MDM_price, Duration_mdm_price, Point, Demand, Index = fun_PriceError_mainMDM(p_subsets_aggr,x_subsets_aggr,vc,Cost)
Pptimalprice_MDMprice, Profit_MDM_price, Duration_mdm_price, Point, Demand, Index = fun_PriceError_max_mainMDM(p_subsets_aggr,x_subsets_aggr,vc,Cost,UserConstraints)


# The function includes two main functions. 
# * One is estimation function $\textit{estimation_Twotypes_l1norm_pulp}$.
# * The other is optimization function $\textit{optimization_MIP_pulp}$

# #### Here is a detailed description of the estimation function: $\textit{estimation_Twotypes_l1norm_pulp}$

# This function solves the following optimization problem
# $$
# \min \sum_{k=1}^M l(\hat{\mathbf{x}} , \hat{\mathbf{p}}, \mathbf{\theta}) = \min_{\mathbf{x}(\hat{\mathbf{p}}) \in \mathcal{S}(\theta, \hat{\mathbf{p}})} \sum_{k=1}^M \| \mathbf{p}(\mathbf{x}(\hat{\mathbf{p}})) - \mathbf{p}(\hat{\mathbf{x}})\|_1
# $$Here the hat symbol $\hat{}$ denoted the observed value, and
# $$
# \mathcal{S}(\theta, \hat{\mathbf{p}}) = \Bigg\{ \mathbf{x}\ \Bigg| \ \hat{p}_j =  -\frac{1}{\alpha} C_j'(x_j, \theta_j) + \frac{1}{\alpha}C_0'(x_0,\theta_0) \ \forall j, \ \sum_{j=0}^N  x_j = 1, \mathbf{x} \geq 0  \Bigg\}
# $$is the constraint for the optimality in pricing.
# 
# We see that $\mathbf{p}(\mathbf{x}(\hat{\mathbf{p}})) = \hat{\mathbf{p}}$. Hence we are actually working on finding best price prediction $\mathbf{p}(\cdot)$ that minimizes the empirical l1-norm loss between predicted price and observed price
# 
# The MDM method looks for finding the optimal $p_j \in \mathscr{H}:=\bigg \{ f = - \frac{1}{\alpha}\big(C_j' - C_0'\big)  \ \bigg| \ C_j, -C_0 \textit{ is piecewise linear convex function} \bigg \}$ \
# Optimize the prediciton function $f$ inside the set $\mathscr{H}$ makes the corresponding optimization tractable, which is formulated as 
# $$
# \begin{align}
# \min_{\mathbf{y}} & \sum_{k=1}^M \sum_{i=1}^n t_{ki} \\
# \textit{s.t. } & -\hat{y}_{kt} + \hat{y}_{k0} - p_{kt}  \leq t_{ki} \\
# & \hat{y}_{kt} - \hat{y}_{k0} + p_{kt} \leq t_{ki} \\
# & \hat{\mathbf{y}} \in \mathcal{Y}\\
# \end{align}
# $$Here $\hat{y}_{ki}$ represent the estimated function value $ C_j'(\hat{x}_{kt})$ at observered share $\hat{x}_{kt}$.\
# We need to ensure these $\hat{y}_{kt}$ statisfy the monotone constraint (by convexity of $C_j(\cdot)$), so we impose the shape constraint $\hat{\mathbf{y}} \in \mathcal{Y}$. A detailed description of $\mathcal{Y}$ can be found in (16) of the paper

# #### Here is a detailed description of the optimization function:  $\textit{optimization_MIP_pulp}$

# This function derives the optimal price (and market share) of the products, given the observed market share among different customers' in the pool
# 
# The optimization problem is formulated in the following way
# $$
# \begin{align}
# \max_{\mathbf{x}, \delta, \mathbf{FI}}\quad &   -\sum_{i=1}^n \omega_i x_i - \sum_{i=1}^n \delta_i  + \delta_0 \\
# \textit{s.t. }  \quad & \delta_j \in PF(x_j; \hat{\mathbf{x}}_{r^j} ; \hat{\mathbf{x}}_{r^j} \circ  \hat{\mathbf{y}}_{r^j})\\
# & \delta_0  \in PF(x_0; \hat{\mathbf{x}}_{r^0} ; ( 1- \hat{\mathbf{x}}_{r^0}) \circ  \hat{\mathbf{y}}_{r^0})\\
# &FI_j \in PF(x_j; \hat{\mathbf{x}}_{r^j} ; \hat{\mathbf{y}}_{r^j})\\
# &(-FI_1 + FI_0, ... , -FI_n +FI_0) \in  \Omega\\ 
# & x_j \leq \hat{x}_{r_K^j j}, \\
# & x_j \leq \hat{x}_{r_1^j j}, \\
# &\mathbf{x} \geq 0,  \sum_{i=0}^n x_i  =1 \\
# \end{align}
# $$
# Here
# 

# $$
# w_j : \textit{the cost of product j}
# \circ : \textit{entry-wise multiplication}\\
# \delta_0 : \textit{the predicted } (1 - x_0) C_0'(x_0) \textit{ at } x_0 \\
# \delta_j : \textit{the predicted } x_j C_j'(x_j) \textit{ at } x_j \textit{ for } j \neq 0\\
# FI_j : \textit{the predicted } C_j'(x_j) \textit{ at } x_j  \\
# \hat{\mathbf{x}}_{r^j}: \textit{observed market share of product } j \textit{ of all customers, sorted in ascending sequence}\\ 
# PF(u;v;w): \textit{mapping the value } u \textit{ to } f(u)  \textit{ , where } f(\cdot) \textit{ is piecewise-linearly approximated by the observation pair } (u,w) \\
# \Omega : \textit{extra constraints regarding the the price, since the optimal price } p_j^* = -FI_j + FI_0
# $$
# 
# In short, $PF(\cdot;\cdot;\cdot)$ is a MIP formulation of the piecewise-linear function oracle.\
# We refer our readers to section 4.3 of the paper to see the details of $PF(\cdot;\cdot;\cdot)$. 

# ## Part 1b.3 Pricing with Calibrated MNL Model

# ##### Input to MNL based Benchmark

# In[27]:


for t in range(MaxSimIter):
    print("Prices and shares for "+str(n)+" product at "+str(MaxIter)+" time periods in " + str(t) +"'s experiment are:")
    data_v=np.c_[p_subsets_aggr[:,:,0],x_subsets_aggr[:,:,0]]
    cn_v=np.r_[np.array(["Price "+str(i) for i in range(n)]),np.array(["Share "+str(i) for i in range(n+1)])]
    #np.c_[np.array(["Price "+str(i) for i in range(n)]),np.array(["Share "+str(i) for i in range(n)])]
    df_input_MDM=pd.DataFrame(data_v)
    df_input_MDM.columns = cn_v
    display(df_input_MDM)


# ##### Calibrate the data using MNL model and optimize prices using the calibrated MNL model

# In[28]:


Price_MNL,profit_MNL,duration_MNL = fun_mainMNL(p_subsets_aggr,x_subsets_aggr,vc,Cost)


# * $\textit{profit_MNL}$ derives from the calibrated MNL model 
# * the pricing model is solved by the following model
# $$
# \begin{array}{lllll}
# &\displaystyle \max_{{x}}&
# \displaystyle  \sum_{j=1}^{N}(v_j-w_j)x_j-\sum_{j=1}^{N}x_j\ln(x_j)+\left(\sum_{j=1}^{N}x_j\right)\ln\left(1-\sum_{j=1}^{N}x_j\right)\\
# &\mbox{s.t.}& \displaystyle \sum_{j=1}^{N}x_j\leq 1,&\\
# &&x_j\geq 0, \ \forall j=1,\dots N.\\
# \end{array}
# $$
# where $v_j$ denotes the calibrated utility parameter and $w_j$ denotes cost
# 

# In[29]:


gap_MDM_price, gap_MNL  = fun_evaluate_optimality_gap(profit_true,Profit_MDM_price,profit_MNL)


# * We evaluate the prices from various approaches introduced above using the complete set of valuations in the valuation pool for the tested produsts.
# * Using $\textit{profit_true}$ from MIP model as the benckmark, calculate the profit gap of each profit from 

# ### Output of Profit Comparison

# In[30]:


gap_MDM_price, gap_MNL


# *Obtain the Optimality Gap, a calibration for comparing the pricing quality of all methods above.

# # Experiment 2: Pricing on MNL Choice Model

# Now we consider the pricing strategies on MNL choice model. \
# The population is assumed to have a valuation vector $\mathbf{v} = (v_1,...,v_n)$ for all $n$ products. \
# Given the market price $\mathbf{p} = (p_1,...,p_n)$, the consumers in this population will buy products $i$ with proportion \
# $$
# x_j(\mathbf{p}) = \frac{ e^{v_j - p_j} }{ 1 + \sum_{i=1}^n e^{v_j - p_j}  }
# $$

# In[31]:


Num_product = 10
MNL_Valuation = [ 10 + 5* random.random() for i in range(Num_product) ] 
MNL_Cost = [(0.3 + 0.2 * random.random())* MNL_Valuation[j] for j in range(Num_product)]


# * $\textbf{Num_product}$: $ \textit{ Number of all available products }$
# * $\textbf{MNL_Valuation}$: $\textit{ True valuation vector } \mathbf{v}, \textit{generated uniformly}. \textit{ Specifically, } v_j = 10 + 5 \tilde{u}_i, \textit{with } \tilde{u}_i \sim \textit{Uniform}[0,1] \textit{ and being i.i.d distributed}   $
# * $\textbf{MNL_Cost}:  \textit{Cost vector } \mathbf{w}$, randomly generated around 0.3 to 0.5 of the valuation $\textit{MNL_Valuation}$

# ### Part 2.1 Pricing with Underlying MNL

# ##### Input to Pricing with Underlying MNL Model

# In[32]:


print("Deterministic utility of each product:")
df_trueMNL=pd.DataFrame(MNL_Valuation)
display(df_trueMNL.T)
print("Cost of each product:")
df_trueMNL_cost=pd.DataFrame(MNL_Cost)
display(df_trueMNL_cost.T)


# ##### Solve Pricing with MNL Model with True Utilities

# In[33]:


MNL_xOpt, MNL_price, MNL_profitOpt = PricingMNL(MNL_Valuation, MNL_Cost)
MNL_xOpt, MNL_price, MNL_profitOpt


# * $\textit{PricingMNL}:$
# Obtain the true optimal market share $\mathbf{x}$ given the valuation vector $\mathbf{v}$ and price $\mathbf{p}$ by the solving the optimization problem
# 
# $$
# \begin{align}
# \max_{x} & \sum_{j=1}^n (v_j - w_j) x_j - \sum_{j=1}^n x_j \ln(x_j) + \bigg( \sum_{j=1}^n  x_j \bigg) \ln\bigg( 1 - \sum_{j=1}^n x_j\bigg) \\
# \textit{s.t. } & \sum_{j=1}^n x_j  \leq 1  \\
# & x_j \geq 0, \forall j = 1,...,n.\\
# \end{align}
# $$

# ### Part 2.2 Pricing with MDM Model

# In[34]:


Rate_pricePurturb_range=0.2 
MaxIter=50 


# * Set parameters of the experiment 
# * $\textit{MaxIter}$: specifies the number of experiment for the MDM model 
# * $\textit{Rate_pricePurturb_range}$: specifies the range of experiment prices around the mean utility 

# In[35]:


MNL_experiment_price=pricePurturb_geneartion_uniform(MNL_Valuation,MaxIter,Rate_pricePurturb_range)


# * Let's change the price a little bit to see how the demand goes. We generate a series of new pricing by changing the price uniformly around $\textit{Rate_pricePurturb_range}$ (20%) of the utility mean $\textit{MNL_Valuation}$. 
# * The experiment price of product $i$ is characterized by $\textit{MNL_experiment_price}$. 
# * To note, the experiment price range should be above the cost range to ensure positive share for each product.

# In[36]:


MNL_experiment_share=MNL_share_geneartion(MNL_Valuation, MNL_experiment_price)


# * Get the share data for experimented prices using the underlying MNL model

# ##### Input Data of MDM Model

# In[37]:


print("Prices and shares for "+str(Num_product)+" product at "+str(MaxIter)+" time periods:")
data_v_trueMNL=np.c_[MNL_experiment_price,MNL_experiment_share]
cn_v_trueMNL=np.r_[np.array(["Price "+str(i) for i in range(Num_product)]),np.array(["Share "+str(i) for i in range(Num_product+1)])]
#np.c_[np.array(["Price "+str(i) for i in range(n)]),np.array(["Share "+str(i) for i in range(n)])]
df_input_MDM_trueMNL=pd.DataFrame(data_v_trueMNL)
df_input_MDM_trueMNL.columns = cn_v_trueMNL
display(df_input_MDM_trueMNL)


# ##### Pricing with MDM Model using experiment data

# In[38]:


MNL_Purturbed_price_post, MNL_Share_mat_purturbed, MNL_idx_purturbed = data_preprocess(MNL_experiment_price, MNL_experiment_share)


# * $\textit{MNL_share_geneartion}$: Use underlying MNL to get the share of each experiment price 
# * $\textit{data_preprocess}$: do some data preprocess to get the input of MDM 

# In[39]:


MNL_Point_purturbed, MNL_Error_purturbed = estimation_Twotypes_l1norm_pulp(MNL_idx_purturbed, MNL_Share_mat_purturbed, 
                                                                           MNL_Purturbed_price_post)
MDM_opt_price, MDM_opt_profit_estimated = optimization_MIP_pulp(MNL_Cost, MNL_Share_mat_purturbed, MNL_Point_purturbed, MNL_idx_purturbed,UserConstraints)[2:4]
MDM_opt_price, MDM_opt_profit_estimated


# * Obtain the solution of pricing and the estimated profit from MDM method 

# In[40]:


MDM_opt_share = Share_calculation_MNL(MNL_Valuation, MDM_opt_price)


# In[41]:


MDM_opt_profit = sum( (MDM_opt_price[j] - MNL_Cost[j]) * MDM_opt_share[j] for j in range(Num_product) )
MDM_opt_profit


# * Obtain the true optimal profit from the underlying MNL model sepcified by $\textit{MNL_Valuation}$.

# ### Output of Profit Comparison

# In[42]:


Local_profit_strucuture_prediction_calib = 1 - abs(MDM_opt_profit - MDM_opt_profit_estimated)/ abs(MDM_opt_profit)
Local_profit_strucuture_prediction_calib 


# * Evaluate the approximability regarding profit estimation of MDM method. 
# * Results shows that it has been estimating the profit well locally.

# In[43]:


Global_profit_optimization_calib = 1 - abs(MDM_opt_profit - MNL_profitOpt )/  abs(MNL_profitOpt)
Global_profit_optimization_calib 


# * Evaluate the quality of pricing with respect to profit 
# * Small size of trainning data fails to catch the full shape of consumer choice model
# * Try to improve the results by generate more and better training price data!

# 
# 
# # Experiment 3: Pricing on Automobile Sales Data. 

# * Note 1. Since we never know the true nature from the observed data, we impose elasticity demand assumption as true underlying nature. 

# In[44]:


curr_path = os.getcwd()
curr_path


# * Get your current work path, put the GM Motor data in this path 

# In[45]:


os.chdir(curr_path)


# * Set path

# ## Access data from csv files 

# In[46]:


# sys.argv[1] = 'GM_baseData.csv'
# sys.argv[2] = 'GM_salesdata.csv'
GM_salesDataFrame =  pd.read_csv('../data/'+sys.argv[2],na_filter=False) 
GM_salesData = GM_salesDataFrame.values
GM_BaseDataFrame =  pd.read_csv('../data/'+sys.argv[1],na_filter=False)
GM_BaseData = GM_BaseDataFrame.values


# * $\textit{GM_salesData}$: record price change rate (-10%, -5%, 0, 5%, 10% ) and sales data in 81 periods
# * $\textit{GM_BaseData}$: record baseline price to calculate the prices in each period

# In[47]:


baseprice=GM_BaseData[:,0]/1000 #######scale down by 1000
#######Preprocess data
MaxIter, nc = GM_salesData.shape ###return the sample size and number of columns
n=len(baseprice);
x_real = GM_salesData[:,(n+2):(2*n+2)]
x_outside= GM_salesData[:,n+1]
x=np.column_stack((x_real.tolist(), x_outside.tolist()))
##calculate price
p_deviation = GM_salesData[:,1:n+1]#####index starts from 0, the first column in GM_salesData is the sequernce number of run, hence needs to exlcude the first column
p = np.zeros((MaxIter,n))
for i in range(MaxIter):
    for j in range(n):
        p[i,j]=baseprice[j]*(1+p_deviation[i,j]/100)


# * Some preprocess work to get the prices and shares in 81 periods 
# * Scale down by 1000 hence the unit is thousand

# In[48]:


baseprice=p[0,:]
baseshare=x[0,:]
cost=GM_BaseData[:,1]/1000 #######scale down by 1000


# * Here Cost overwrite the variables in experiment one. Just a reminder
# * Use the data in the first period as the baseprice and baseshare

# ##### Input Data for the Case Study

# In[49]:


print("Prices and shares for "+str(n)+" product at "+str(MaxIter)+" time periods:")
data_v_GM=np.c_[p,x]
cn_v_GM=np.r_[np.array(["Price "+str(i) for i in range(n)]),np.array(["Share "+str(i) for i in range(n+1)])]
df_input_MDM_GM=pd.DataFrame(data_v_GM)
df_input_MDM_GM.columns = cn_v_GM
display(df_input_MDM_GM)
print("Cost for each product:")


# ## Part 3.1 Price Optimization 

# ### Part 3.1.1 Pricing with MDM Model

# In[50]:


P,demand,index=data_preprocess(p,x)


# * $\textit{data_preprocess}$: do some data preprocess to get the input of MDM 

# In[51]:


# point,error = estimation_Twotypes_l1norm_pulp(index,demand,P)
# point,error = estimation_Twotypes_max_l1norm_pulp(index,demand,P)
# point,error = estimation_Monotone_l1norm_pulp(index,demand,P)
point,error = estimation_Monotone_max_l1norm_pulp(index,demand,P)


# * Estimate MDM!

# In[52]:


print(UserConstraints)
optx, optdelta, MDM_price, MDM_profit_estimated = optimization_MIP_pulp_GM(cost,demand,point,index,baseprice,UserConstraints)


# In[53]:


MDM_price


# * Optimize MDM, with price constraint
# $$
# 0.9 baseprice_i\leq p_i \leq 1.1 baseprice_i
# $$
# i.e. the price adjustment should be within 10% of the baseprice

# ###  Part 3.1.2 Pricing with Elasticity (Ground Truth)

# In[54]:


ElasticityM=Get_Elasticity(p,x)
price_elasticity=QP_Elasticity(ElasticityM, baseprice, baseshare, cost)


# * $\textit{Get_Elasticity}$: get the elasticity coefficients
# * $\textit{QP_Elasticity}$: get the true optimal price using elasticity (Ground Truth)

# ### Part 3.1.3. Pricing with MNL Model

# In[55]:


########calibrate MNL model
V_MNL,error_MNL=calibration_MNL_pulp(p,x)
#######optimimize MNL model
optx_MNL,Price_MNL,profit_MNL = PricingMNL(V_MNL,cost)


# * $\textit{calibration_MNL_pulp}$: Calibrate the MNL model from data
# * $\textit{PricingMNL}$: Pricing with calibrated MNL model

# ### Part 3.1.4 Pricing with Nested Logit Model

# In[56]:


nk=[7,7,6] #######by brand 
K=len(nk)
V_NL,InvTau_NL, error_NL=calibration_NL_pulp(p,x,nk)
v_tau=np.zeros((K,1))
for k in range(K):
    v_tau[k]=1/InvTau_NL[k]
optx_NL,Price_NL,profit_NL=PricingNL(V_NL,nk,v_tau,cost)


# * $\textit{calibration_NL_pulp}$: Calibrate the NL model from data
# * $\textit{PricingNL}$: Pricing with calibrated NL model

# ### Price Evaluation Under Elasticity Model and Profit Comparison

# In[57]:


####Elasticity
share_elasticity=share_evaluation_Elasticity(price_elasticity,ElasticityM,baseprice,baseshare)
Profit_Opt=np.dot(price_elasticity-cost,share_elasticity[0:n]) 
#####MDM
share_MDM=share_evaluation_Elasticity(MDM_price,ElasticityM,baseprice,baseshare)
profit_MDM=np.dot(MDM_price-cost,share_MDM[0:n])
####MNL
share_MNL=share_evaluation_Elasticity(Price_MNL,ElasticityM,baseprice,baseshare)
profit_MNL=np.dot(Price_MNL-cost,share_MNL[0:n])
####NL
share_NL=share_evaluation_Elasticity(Price_NL,ElasticityM,baseprice,baseshare)
profit_NL=np.dot(Price_NL-cost,share_NL[0:n])
Profit_Opt, profit_MDM, profit_MNL, profit_NL


# ### Price Comparison

# In[58]:


print("Prices from each method are:")
data_price_GM=np.c_[baseprice,price_elasticity,MDM_price,Price_MNL,Price_NL]
cn_price_GM=('BasePrice','True','MDM','MNL','NL')
df_price_MDM_GM=pd.DataFrame(data_price_GM)
df_price_MDM_GM.columns = cn_price_GM
display(df_price_MDM_GM)


# * Evaluate Prices obtained from Various Approaches under Elasticity assumption

# In[59]:


Curr_profit = sum( (baseprice[i] -cost[i]) * baseshare[i] for i in range(len(baseprice))) 
Curr_profit
# print("Profit: "+Curr_profit)


# * Real retail Profit

# ## Part 3.2 Prediction Accuracy

# #### cross validation

# In[60]:


m_in=80
m_out=1
MaxSimIter=50


# * $\textit{m_in}$: We use 80 data points (in-sample data) to calibrate the model 
# * $\textit{m_out}$: and predict the market share under the remaining experiment (out-sample data) 
# * $\textit{MaxSimIter}$: We repeat this experiment 50 times.

# In[61]:


p_in, x_in, p_out, x_out = cross_validation_SeperateSample(m_in,m_out,MaxSimIter,p,x)


# * $\textit{cross_validation_SeperateSample}$: seperate data into insample and out-sample data set

# #### Cross Validation Using Different Models

# In[62]:


##########cross validation using MDM
profit_out_fit_MDM, x_out_fit_MDM, error_predict_MDM, error_predict_shareMSE_MDM = cross_validation_MDM_pulp(p_in, x_in, p_out, x_out, cost)
##########cross validation using MNL
profit_out_fit_MNL, x_out_fit_MNL, error_predict_MNL, error_predict_shareMSE_MNL = cross_validation_MNL_pulp(p_in, x_in, p_out, x_out, cost)
##########cross validation using NL
profit_out_fit_NL, x_out_fit_NL, error_predict_NL, error_predict_shareMSE_NL=cross_validation_NL_pulp(p_in, x_in, p_out, x_out, cost,nk)
########## validation using elasticity
profit_out_fit_Elasticity, x_out_fit_Elasticity, error_predict_Elasticity, error_predict_shareMSE_Elasticity=outsample_validation_elasticity(ElasticityM ,p, x, p_out, x_out, cost,nk)


# * $\textit{cross_validation_MDM_pulp}$: Cross validation using MDM model
# * $\textit{cross_validation_MNL_pulp}$: Cross validation using MNL model
# * $\textit{cross_validation_NL_pulp}$: Cross validation using NL model
# * $\textit{outsample_validation_elasticity}$: Cross validation using Elasticity model

# In[63]:


fun_plot_OutSample_Share(x_out,x_out_fit_MDM,x_out_fit_MNL,x_out_fit_NL,x_out_fit_Elasticity)
# fun_plot_OutSample_Share(x_out,x_out_fit_MNL,x_out_fit_MNL,x_out_fit_NL,x_out_fit_MNL)


# * Plot the prediction of the outsample for differen models

# ##### Mean of Prdiction Error

# In[64]:


[np.mean(error_predict_MDM),np.mean(error_predict_MNL),np.mean(error_predict_NL),np.mean(error_predict_Elasticity)]


# ##### STD of Prdiction Error

# In[65]:


[np.std(error_predict_MDM),np.std(error_predict_MNL),np.std(error_predict_NL),np.std(error_predict_Elasticity)]


# ##### Mean of Prdiction MSE

# In[66]:


[np.mean(error_predict_shareMSE_MDM),np.mean(error_predict_shareMSE_MNL),np.mean(error_predict_shareMSE_NL),np.mean(error_predict_shareMSE_Elasticity)]


# ##### STD of Prdiction MSE

# In[67]:


[np.std(error_predict_shareMSE_MDM),np.std(error_predict_shareMSE_MNL),np.std(error_predict_shareMSE_NL),np.std(error_predict_shareMSE_Elasticity)]


# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:




